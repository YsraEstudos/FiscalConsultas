==================================================
FILE: client/src/services/api.ts
==================================================
/**
 * API Client - Axios com autentica√ß√£o Clerk
 * 
 * Configura√ß√£o centralizada do axios com:
 * - Base URL normalizada
 * - Interceptor para adicionar JWT do Clerk em cada request
 * - Timeout configur√°vel
 */
import axios, { AxiosError, InternalAxiosRequestConfig } from 'axios';
import type { SystemStatusResponse } from '../types/api.types';

const explicitBaseUrl = import.meta.env.VITE_API_FILTER_URL || import.meta.env.VITE_API_URL;
const isLocalHost = (host: string) => host === 'localhost' || host === '127.0.0.1';
const isExplicitLocalApi =
    !!explicitBaseUrl &&
    /^https?:\/\/(?:localhost|127\.0\.0\.1)(?::\d+)?(?:\/|$)/i.test(explicitBaseUrl);
const shouldUseProxyApi =
    typeof window !== 'undefined' && isExplicitLocalApi && !isLocalHost(window.location.hostname);

const rawBaseUrl = shouldUseProxyApi ? '/api' : (explicitBaseUrl || '/api');

const normalizeApiUrl = (base: string) => {
    const trimmed = base.replace(/\/$/, '');

    if (trimmed === '/api' || trimmed.startsWith('/api/')) {
        return trimmed;
    }

    if (/^https?:\/\//i.test(trimmed)) {
        if (trimmed.endsWith('/api')) return trimmed;
        if (trimmed.endsWith('/api/')) return trimmed.slice(0, -1);
        return `${trimmed}/api`;
    }

    return trimmed;
};

const API_URL = normalizeApiUrl(rawBaseUrl);

export const api = axios.create({
    baseURL: API_URL,
    timeout: 60000,
    withCredentials: true,
});

// ============================================================
// AUTH INTERCEPTOR - Injeta o JWT do Clerk em cada request
// ============================================================

/**
 * Storage para o token getter do Clerk.
 * Isso √© necess√°rio porque o interceptor do axios √© configurado uma vez,
 * mas o getToken() vem do hook useAuth que s√≥ existe dentro de componentes React.
 */
let clerkGetToken: (() => Promise<string | null>) | null = null;

/**
 * Registra a fun√ß√£o getToken do Clerk para uso no interceptor.
 * Deve ser chamado uma vez quando o AuthProvider monta.
 */
export function registerClerkTokenGetter(getter: () => Promise<string | null>) {
    clerkGetToken = getter;
}

/**
 * Remove a fun√ß√£o getToken (chamado no unmount do AuthProvider).
 */
export function unregisterClerkTokenGetter() {
    clerkGetToken = null;
}

// Request interceptor para adicionar o token JWT
api.interceptors.request.use(
    async (config: InternalAxiosRequestConfig) => {
        // Se temos um getter de token registrado, busca o token
        if (clerkGetToken) {
            try {
                const token = await clerkGetToken();
                if (token) {
                    config.headers.set('Authorization', `Bearer ${token}`);
                }
            } catch (error) {
                // Falha silenciosa - request continua sem token
                console.warn('[API] Failed to get auth token:', error);
            }
        }
        return config;
    },
    (error: AxiosError) => {
        return Promise.reject(error);
    }
);

// Response interceptor para tratar erros de autentica√ß√£o
api.interceptors.response.use(
    (response) => response,
    (error: AxiosError) => {
        if (error.response?.status === 401) {
            // Token expirado ou inv√°lido
            console.warn('[API] 401 Unauthorized - Token may be expired');
            // Aqui poderia disparar um evento para o AuthContext for√ßar re-auth
        }
        return Promise.reject(error);
    }
);

// ============================================================
// API FUNCTIONS
// ============================================================

// ============================================================
// PERFORMANCE: In-memory + localStorage cache for chapter data
// ============================================================
const CACHE_PREFIX = 'nesh_cache_';
const CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour
const CACHE_MAX_ENTRIES = 30;

interface CacheEntry<T> {
    data: T;
    timestamp: number;
}

// In-memory cache (fastest - survives within session)
const memoryCache = new Map<string, CacheEntry<any>>();

function getCached<T>(key: string): T | null {
    // 1. Check memory cache first (fastest)
    const memEntry = memoryCache.get(key);
    if (memEntry && Date.now() - memEntry.timestamp < CACHE_TTL_MS) {
        return memEntry.data;
    }
    if (memEntry) memoryCache.delete(key);

    // 2. Check localStorage (survives page reloads)
    try {
        const raw = localStorage.getItem(CACHE_PREFIX + key);
        if (raw) {
            const entry: CacheEntry<T> = JSON.parse(raw);
            if (Date.now() - entry.timestamp < CACHE_TTL_MS) {
                // Promote to memory cache
                memoryCache.set(key, entry);
                return entry.data;
            }
            localStorage.removeItem(CACHE_PREFIX + key);
        }
    } catch {
        // localStorage unavailable or corrupt - ignore
    }
    return null;
}

function setCache<T>(key: string, data: T): void {
    const entry: CacheEntry<T> = { data, timestamp: Date.now() };

    // Memory cache
    memoryCache.set(key, entry);

    // localStorage (with eviction)
    try {
        // Evict old entries if too many
        const keys: string[] = [];
        for (let i = 0; i < localStorage.length; i++) {
            const k = localStorage.key(i);
            if (k?.startsWith(CACHE_PREFIX)) keys.push(k);
        }
        if (keys.length >= CACHE_MAX_ENTRIES) {
            // Remove oldest entries
            const entries = keys.map(k => {
                try {
                    const v = JSON.parse(localStorage.getItem(k) || '{}');
                    return { key: k, ts: v.timestamp || 0 };
                } catch { return { key: k, ts: 0 }; }
            });
            entries.sort((a, b) => a.ts - b.ts);
            for (let i = 0; i < Math.min(10, entries.length); i++) {
                localStorage.removeItem(entries[i].key);
            }
        }
        localStorage.setItem(CACHE_PREFIX + key, JSON.stringify(entry));
    } catch {
        // localStorage full or unavailable - memory cache still works
    }
}

export const searchNCM = async (query: string): Promise<any> => {
    // Performance: Check cache for code queries (chapter data is static)
    const cacheKey = `nesh:${query}`;
    const cached = getCached<any>(cacheKey);
    if (cached) return cached;

    const response = await api.get(`/search?ncm=${encodeURIComponent(query)}`);
    const data = response.data;

    // Normalize: backend no longer sends 'resultados' (v4.3 ‚Äî saves ~860KB per response).
    // We add a JS reference so existing components (Sidebar, ResultDisplay) keep working.
    if (data?.type === 'code' && data?.results) {
        data.resultados = data.results; // JS ref copy, zero memory cost
    }

    // Cache code search results (chapter data). Text search is not cached.
    if (data?.type === 'code' && data?.success) {
        setCache(cacheKey, data);
    }
    return data;
};

export const searchTipi = async (query: string, viewMode: 'chapter' | 'family' = 'family'): Promise<any> => {
    // Performance: Check cache for code queries
    const cacheKey = `tipi:${query}:${viewMode}`;
    const cached = getCached<any>(cacheKey);
    if (cached) return cached;

    const response = await api.get(`/tipi/search?ncm=${encodeURIComponent(query)}&view_mode=${viewMode}`);
    const data = response.data;

    // Normalize: backend no longer sends 'resultados' (v4.3)
    if (data?.type === 'code' && data?.results) {
        data.resultados = data.results;
    }

    // Cache code search results
    if (data?.type === 'code' && data?.success) {
        setCache(cacheKey, data);
    }
    return data;
};

export const getGlossaryTerm = async (term: string): Promise<any> => {
    const response = await api.get(`/glossary?term=${encodeURIComponent(term)}`);
    return response.data;
};

export const getSystemStatus = async (): Promise<SystemStatusResponse> => {
    const response = await api.get('/status');
    return response.data;
};

export const getAuthSession = async (): Promise<{ authenticated: boolean }> => {
    const response = await api.get('/auth/me');
    return response.data;
};

/**
 * Busca notas de um cap√≠tulo espec√≠fico (cross-chapter references).
 * Usado para acessar notas de cap√≠tulos n√£o carregados no contexto atual.
 */
export const fetchChapterNotes = async (chapter: string): Promise<{
    success: boolean;
    capitulo: string;
    notas_parseadas: Record<string, string>;
    notas_gerais: string | null;
}> => {
    const response = await api.get(`/nesh/chapter/${encodeURIComponent(chapter)}/notes`);
    return response.data;
};


==================================================
FILE: client/src/hooks/useSearch.ts
==================================================
import { useCallback } from 'react';
import axios from 'axios';
import { toast } from 'react-hot-toast';
import { searchNCM, searchTipi } from '../services/api';
import { useTabs, type Tab, type DocType } from './useTabs';
import { useHistory } from './useHistory';
import { useSettings } from '../context/SettingsContext';
import { extractChapter, isSameChapter } from '../utils/chapterDetection';
import type { SearchResponse } from '../types/api.types';
import { isCodeSearchResponse } from '../types/api.types';

const buildLoadedChaptersByDoc = (value?: Record<DocType, string[]>): Record<DocType, string[]> => ({
    nesh: value?.nesh ?? [],
    tipi: value?.tipi ?? []
});

export function useSearch(
    tabsById: ReturnType<typeof useTabs>['tabsById'],
    updateTab: ReturnType<typeof useTabs>['updateTab'],
    addToHistory: ReturnType<typeof useHistory>['addToHistory']
) {
    const { tipiViewMode } = useSettings();

    const updateResultsQuery = useCallback((results: SearchResponse, query: string): SearchResponse => {
        return { ...results, query };
    }, []);

    const updateTabSearchState = useCallback((
        tabId: string,
        updates: Partial<Pick<
            Tab,
            'ncm' | 'title' | 'results' | 'loading' | 'error' | 'isNewSearch' | 'loadedChaptersByDoc' | 'content' | 'isContentReady'
        >>
    ) => {
        updateTab(tabId, updates);
    }, [updateTab]);

    const executeSearchForTab = useCallback(async (tabId: string, doc: DocType, query: string, saveHistory: boolean = true) => {
        if (!query) return;

        if (saveHistory) addToHistory(query);

        // Localiza a aba atual para consultar cap√≠tulos carregados
        const currentTab = tabsById.get(tabId);
        const loadedChaptersByDoc = buildLoadedChaptersByDoc(currentTab?.loadedChaptersByDoc);
        const loadedChaptersForDoc = loadedChaptersByDoc[doc];
        const targetChapter = extractChapter(query);

        // OTIMIZACAO: Navegacao no mesmo capitulo
        // Se o NCM alvo pertence a um capitulo ja carregado, pula o fetch e apenas dispara auto-scroll
        // CRITICO: Atualizar results.query para manter sincronizado com o targetId do ResultDisplay
        if (
            targetChapter &&
            loadedChaptersForDoc.length > 0 &&
            isSameChapter(query, loadedChaptersForDoc) &&
            currentTab?.results // Precisa ter resultados existentes para atualizar
        ) {
            // Pula o fetch - atualiza results.query e dispara auto-scroll
            updateTabSearchState(tabId, {
                ncm: query,
                title: query,
                // CRITICO: Atualiza results.query para manter sincronizado com o ResultDisplay
                results: updateResultsQuery(currentTab.results, query),
                isNewSearch: true
            });
            return; // Early exit - sem chamada a API
        }

        // Fluxo normal: buscar novos dados
        updateTabSearchState(tabId, {
            loading: true,
            error: null,
            ncm: query,
            title: query,
            isContentReady: false
        });

        try {
            const data = doc === 'nesh'
                ? await searchNCM(query)
                : await searchTipi(query, tipiViewMode);

            // Extrai capitulos apenas para respostas do tipo code
            const chaptersInResponse = isCodeSearchResponse(data) && data.resultados
                ? Object.keys(data.resultados)
                : [];
            const nextLoadedChaptersForDoc = chaptersInResponse.length > 0
                ? [...new Set([...loadedChaptersForDoc, ...chaptersInResponse])]
                : [];

            updateTabSearchState(tabId, {
                results: updateResultsQuery(data, query),
                content: data.markdown || data.resultados || '',
                loading: false,
                isNewSearch: true,
                isContentReady: false,
                // Atualiza capitulos carregados apenas do documento atual
                loadedChaptersByDoc: {
                    ...loadedChaptersByDoc,
                    [doc]: nextLoadedChaptersForDoc
                }
            });
        } catch (err: any) {
            console.error(err);
            let message = 'Erro ao buscar dados. Verifique a API.';

            if (axios.isAxiosError(err)) {
                const status = err.response?.status;
                if (status === 404) {
                    message = 'Endpoint n√£o encontrado (404). Verifique se o backend est√° rodando e se a base URL est√° correta.';
                } else if (status) {
                    message = `Erro ${status} ao buscar dados. Verifique a API.`;
                } else if (err.code === 'ECONNABORTED') {
                    message = 'Tempo limite na requisi√ß√£o. Verifique a conex√£o com o backend.';
                } else if (err.code === 'ERR_NETWORK') {
                    message = 'N√£o foi poss√≠vel conectar √† API. Verifique se o backend est√° em execu√ß√£o.';
                }
            }

            toast.error(message);
            updateTabSearchState(tabId, {
                error: message,
                loading: false
            });
        }
    }, [addToHistory, tipiViewMode, tabsById, updateResultsQuery, updateTabSearchState]);

    return { executeSearchForTab };
}


==================================================
FILE: client/src/context/CrossChapterNoteContext.tsx
==================================================
/**
 * CrossChapterNoteContext
 * 
 * Context para cache e fetch de notas de cap√≠tulos n√£o carregados.
 * Permite acessar notas de qualquer cap√≠tulo sem precisar carregar o cap√≠tulo inteiro.
 */

import { createContext, useContext, useState, useCallback, useRef, useEffect, ReactNode } from 'react';
import { fetchChapterNotes } from '../services/api';

// Tipos
interface NotesCache {
    [chapterNum: string]: Record<string, string>; // notas_parseadas por cap√≠tulo
}

interface CrossChapterNoteContextValue {
    cache: NotesCache;
    fetchNotes: (chapter: string) => Promise<Record<string, string>>;
    getNote: (chapter: string, noteNum: string) => string | null;
    isLoading: (chapter: string) => boolean;
}

// Context
const CrossChapterNoteContext = createContext<CrossChapterNoteContextValue | null>(null);

// Provider Props
interface CrossChapterNoteProviderProps {
    children: ReactNode;
}

/**
 * Provider que gerencia cache de notas cross-chapter.
 * 
 * Performance:
 * - useRef para tracking de fetches em andamento (evita race conditions)
 * - Cache persiste no estado (evita re-fetches)
 * - useCallback est√°vel para evitar re-renders
 */
export function CrossChapterNoteProvider({ children }: CrossChapterNoteProviderProps) {
    const [cache, setCache] = useState<NotesCache>({});
    const cacheRef = useRef<NotesCache>({});
    const inFlightRef = useRef<Map<string, Promise<Record<string, string>>>>(new Map());

    useEffect(() => {
        cacheRef.current = cache;
    }, [cache]);

    /**
     * Busca notas de um cap√≠tulo espec√≠fico.
     * Retorna do cache se dispon√≠vel, sen√£o faz fetch e cacheia.
     */
    const fetchNotes = useCallback(async (chapter: string): Promise<Record<string, string>> => {
        const cached = cacheRef.current[chapter];
        if (cached) {
            return cached;
        }

        const inFlight = inFlightRef.current.get(chapter);
        if (inFlight) {
            return inFlight;
        }

        const request = fetchChapterNotes(chapter)
            .then(response => {
                const notesData = response?.notas_parseadas || {};
                cacheRef.current = { ...cacheRef.current, [chapter]: notesData };
                setCache(prev => (prev[chapter] ? prev : { ...prev, [chapter]: notesData }));
                return notesData;
            })
            .catch(error => {
                console.error(`[CrossChapterNote] Erro ao buscar notas do cap√≠tulo ${chapter}:`, error);
                throw error;
            })
            .finally(() => {
                inFlightRef.current.delete(chapter);
            });

        inFlightRef.current.set(chapter, request);
        return request;
    }, []);

    /**
     * Obt√©m uma nota espec√≠fica do cache (s√≠ncrono).
     * Retorna null se n√£o estiver em cache.
     */
    const getNote = useCallback((chapter: string, noteNum: string): string | null => {
        return cacheRef.current[chapter]?.[noteNum] || null;
    }, []);

    /**
     * Verifica se um cap√≠tulo est√° sendo carregado.
     */
    const isLoading = useCallback((chapter: string): boolean => {
        return inFlightRef.current.has(chapter);
    }, []);

    const value: CrossChapterNoteContextValue = {
        cache,
        fetchNotes,
        getNote,
        isLoading
    };

    return (
        <CrossChapterNoteContext.Provider value={value}>
            {children}
        </CrossChapterNoteContext.Provider>
    );
}

/**
 * Hook para acessar o contexto de notas cross-chapter.
 * Deve ser usado dentro de CrossChapterNoteProvider.
 */
export function useCrossChapterNotes(): CrossChapterNoteContextValue {
    const context = useContext(CrossChapterNoteContext);
    if (!context) {
        throw new Error('useCrossChapterNotes must be used within CrossChapterNoteProvider');
    }
    return context;
}

export default CrossChapterNoteContext;


==================================================
FILE: client/src/App.tsx
==================================================
import { useEffect, useCallback, useState, Suspense } from 'react';

import { Toaster, toast } from 'react-hot-toast';
import { Layout } from './components/Layout';
import { ResultDisplay } from './components/ResultDisplay';
import { TabsBar } from './components/TabsBar';
import { ResultSkeleton } from './components/ResultSkeleton';
import { TabPanel } from './components/Tabs/TabPanel';
import { useTabs } from './hooks/useTabs';
import { useCrossChapterNotes } from './context/CrossChapterNoteContext';
import { useSearch } from './hooks/useSearch';
import { useHistory } from './hooks/useHistory';
import { extractChapter } from './utils/chapterDetection';
import { isCodeSearchResponse } from './types/api.types';
import { useSettings } from './context/SettingsContext';
import { NotePanel } from './components/NotePanel';
import styles from './App.module.css';

import { ModalManager } from './components/ModalManager';

// Declaracao global movida para vite-env.d.ts

function App() {
    const {
        tabs,
        tabsById,
        activeTab,
        activeTabId,
        createTab,
        closeTab,
        switchTab,
        updateTab
    } = useTabs();

    // Estados dos modais
    const [_isSettingsOpen, setIsSettingsOpen] = useState(false);
    const [_isTutorialOpen, setIsTutorialOpen] = useState(false);
    const [isStatsOpen, setIsStatsOpen] = useState(false);
    const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
    const [isComparatorOpen, setIsComparatorOpen] = useState(false);
    const [noteModal, setNoteModal] = useState<{
        note: string;
        chapter: string;
        content: string;
        isCrossChapter?: boolean;
    } | null>(null);

    const { sidebarPosition } = useSettings();

    // Hooks customizados
    const { history, addToHistory, removeFromHistory, clearHistory } = useHistory();
    const { executeSearchForTab } = useSearch(tabsById, updateTab, addToHistory);

    const closeMobileMenu = useCallback(() => setMobileMenuOpen(false), []);
    const noop = useCallback(() => { }, []);
    const resetLoadedChaptersForDoc = useCallback((doc: DocType) => {
        const current = activeTab.loadedChaptersByDoc || { nesh: [], tipi: [] };
        return { ...current, [doc]: [] };
    }, [activeTab.loadedChaptersByDoc]);


    // Atalhos globais de teclado
    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            // Foca a busca com '/'
            if (document.activeElement && e.key === '/' && !['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
                e.preventDefault();
                const searchInput = document.getElementById('ncmInput');
                if (searchInput) searchInput.focus();
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, []);


    type DocType = 'nesh' | 'tipi';


    const splitSearchTerms = useCallback((raw: string) => {
        return raw
            .split(/[,\s]+/)
            .map(term => term.trim())
            .filter(Boolean);
    }, []);

    // Busca atua na aba ativa, mas suporta multiplos NCMs por virgula/espaco
    const handleSearch = useCallback((query: string) => {
        const terms = splitSearchTerms(query);
        if (terms.length === 0) return;

        const doc = (activeTab?.document || 'nesh') as DocType;

        if (terms.length === 1) {
            void executeSearchForTab(activeTabId, doc, terms[0], true);
            return;
        }

        const canReuseActiveTab = !activeTab?.loading && !activeTab?.results && !activeTab?.ncm;
        let startIndex = 0;

        if (canReuseActiveTab) {
            void executeSearchForTab(activeTabId, doc, terms[0], true);
            startIndex = 1;
        }

        for (let i = startIndex; i < terms.length; i += 1) {
            const tabId = createTab(doc);
            void executeSearchForTab(tabId, doc, terms[i], true);
        }
    }, [
        activeTab?.document,
        activeTab?.loading,
        activeTab?.ncm,
        activeTab?.results,
        activeTabId,
        createTab,
        executeSearchForTab,
        splitSearchTerms
    ]);

    const scrollToNotesSection = useCallback((chapter?: string) => {
        const container = document.getElementById(`results-content-${activeTabId}`);
        if (!container) return false;

        const selectors = [
            ...(chapter ? [`#chapter-${chapter}-notas`, `#chapter-${chapter}`, `#cap-${chapter}`] : []),
            '.section-notas',
            '.regras-gerais'
        ];

        let target: HTMLElement | null = null;
        for (const sel of selectors) {
            const el = container.querySelector(sel) as HTMLElement | null;
            if (el) {
                target = el;
                break;
            }
        }

        if (!target) return false;

        target.scrollIntoView({ behavior: 'smooth', block: 'start' });
        target.classList.add('flash-highlight');
        setTimeout(() => target?.classList.remove('flash-highlight'), 2000);
        return true;
    }, [activeTabId]);

    // Hook para notas cross-chapter
    const { fetchNotes: fetchCrossChapterNotes } = useCrossChapterNotes();

    const handleOpenNote = useCallback(async (note: string, chapter?: string) => {
        const results = activeTab?.results;
        if (!results || !isCodeSearchResponse(results)) {
            toast.error('Notas indispon√≠veis para esta aba.');
            return;
        }

        const resultsMap = results.resultados || results.results;
        if (!resultsMap) {
            toast.error('Notas indispon√≠veis para esta aba.');
            return;
        }

        let targetChapter = chapter;
        if (!targetChapter) {
            const fromQuery = extractChapter(activeTab?.ncm || results.query || '');
            if (fromQuery && resultsMap[fromQuery]) {
                targetChapter = fromQuery;
            } else {
                const keys = Object.keys(resultsMap);
                if (keys.length === 1) targetChapter = keys[0];
            }
        }

        // CROSS-CHAPTER: Verificar se o cap√≠tulo est√° carregado localmente
        const isLocalChapter = targetChapter && resultsMap[targetChapter];
        let notesMap: Record<string, string> | null = null;
        let isCrossChapter = false;

        if (isLocalChapter && targetChapter) {
            // Cap√≠tulo local: usar notas j√° carregadas
            const chapterData = (resultsMap as Record<string, any>)[targetChapter] || {};
            notesMap = chapterData?.notas_parseadas || {};
        } else if (targetChapter) {
            // CROSS-CHAPTER: Buscar notas do outro cap√≠tulo
            isCrossChapter = true;
            const loadingToastId = toast.loading(`Carregando notas do Cap√≠tulo ${targetChapter}...`);

            try {
                notesMap = await fetchCrossChapterNotes(targetChapter);
            } catch (error) {
                toast.error(`Erro ao carregar notas do Cap√≠tulo ${targetChapter}.`);
                return;
            } finally {
                toast.dismiss(loadingToastId);
            }
        }

        if (!targetChapter) {
            toast.error('N√£o foi poss√≠vel identificar o cap√≠tulo da nota.');
            return;
        }

        const content = notesMap?.[note];

        if (!content) {
            const scrolled = scrollToNotesSection(targetChapter);
            if (!scrolled) {
                toast.error(`Nota ${note} n√£o encontrada no cap√≠tulo ${targetChapter}.`);
            } else {
                toast(`Nota ${note} n√£o encontrada. Mostrando notas do cap√≠tulo.`);
            }
            return;
        }

        setNoteModal({ note, chapter: targetChapter, content, isCrossChapter });
    }, [activeTab?.ncm, activeTab?.results, fetchCrossChapterNotes, scrollToNotesSection]);

    // Handler de clique em smart-link (delegacao)
    useEffect(() => {
        const handleSmartLinkClick = (event: MouseEvent) => {
            const target = event.target as HTMLElement;
            const smartLink = target.closest('a.smart-link') as HTMLAnchorElement | null;
            if (!smartLink) return;

            event.preventDefault();
            const ncm = smartLink.dataset.ncm;
            if (ncm) {
                handleSearch(ncm);
            }
        };

        document.addEventListener('click', handleSmartLinkClick);
        return () => document.removeEventListener('click', handleSmartLinkClick);
    }, [handleSearch]);

    // Handler de clique em note-ref (delegacao)
    useEffect(() => {
        const handleNoteRefClick = (event: MouseEvent) => {
            const target = event.target as HTMLElement;
            const noteRef = target.closest('.note-ref') as HTMLElement | null;
            if (!noteRef) return;

            const note = noteRef.dataset.note;
            if (!note) return;

            const chapter = noteRef.dataset.chapter;
            handleOpenNote(note, chapter);
        };

        document.addEventListener('click', handleNoteRefClick);
        return () => document.removeEventListener('click', handleNoteRefClick);
    }, [handleOpenNote]);

    const openInDocNewTab = useCallback(async (doc: DocType, ncm: string) => {
        const tabId = createTab(doc);
        await executeSearchForTab(tabId, doc, ncm, false);
    }, [createTab, executeSearchForTab]);

    const openInDocCurrentTab = useCallback(async (doc: DocType, ncm: string) => {
        // Se a aba atual estiver ocupada, abre nova para evitar sobrescrever.
        if (activeTab.results || activeTab.ncm || activeTab.loading) {
            await openInDocNewTab(doc, ncm);
            return;
        }

        updateTab(activeTabId, {
            document: doc,
            results: null,
            content: null,
            error: null,
            ncm: '',
            isContentReady: false, // Reseta estado de pronto
            loadedChaptersByDoc: resetLoadedChaptersForDoc(doc) // Reseta cache de capitulos por documento
        });
        await executeSearchForTab(activeTabId, doc, ncm, false);
    }, [activeTab.loading, activeTab.ncm, activeTab.results, activeTabId, executeSearchForTab, openInDocNewTab, updateTab]);

    // Define o documento na aba ativa (ou abre nova se ja houver conteudo)
    const setDoc = (doc: string) => {
        // Se a aba atual tem resultados ou busca em andamento, abre nova aba
        if (activeTab.results || activeTab.ncm || activeTab.loading) {
            createTab(doc as DocType);
        } else {
            // Se a aba atual esta vazia/inicial, apenas troca o documento
            updateTab(activeTabId, {
                document: doc as DocType,
                results: null,
                content: null,
                error: null,
                ncm: '',
                isContentReady: false, // Reseta estado de pronto
                loadedChaptersByDoc: resetLoadedChaptersForDoc(doc as DocType) // Reseta cache de capitulos por documento
            });
        }
    };

    // Ponte legado + ponte de configuracoes
    useEffect(() => {
        window.nesh = {
            smartLinkSearch: (ncm: string) => {
                handleSearch(ncm);
            },
            openNote: (note: string, chapter?: string) => {
                handleOpenNote(note, chapter);
            },
            openSettings: () => {
                setIsSettingsOpen(true);
            }
        };
        return () => {
            (window as any).nesh = undefined;
        };
    }, [handleOpenNote, handleSearch]);

    return (
        <>
            <Toaster position="top-right" />
            <Suspense fallback={null}>
                <ModalManager
                    modals={{
                        settings: _isSettingsOpen,
                        tutorial: _isTutorialOpen,
                        stats: isStatsOpen,
                        comparator: isComparatorOpen
                    }}
                    onClose={{
                        settings: () => setIsSettingsOpen(false),
                        tutorial: () => setIsTutorialOpen(false),
                        stats: () => setIsStatsOpen(false),
                        comparator: () => setIsComparatorOpen(false)
                    }}
                    currentDoc={(activeTab?.document || 'nesh') as DocType}
                    onOpenInDoc={openInDocCurrentTab}
                    onOpenInNewTab={openInDocNewTab}
                />
            </Suspense>
            <NotePanel
                isOpen={!!noteModal}
                onClose={() => setNoteModal(null)}
                note={noteModal?.note || ''}
                chapter={noteModal?.chapter || ''}
                content={noteModal?.content || ''}
                position={sidebarPosition}
            />

            <Layout
                onSearch={handleSearch}
                doc={activeTab?.document || 'nesh'}
                setDoc={setDoc}
                searchKey={`${activeTabId}-${activeTab?.document || 'nesh'}`}
                onMenuOpen={() => setMobileMenuOpen(prev => !prev)}
                onOpenSettings={() => setIsSettingsOpen(true)}
                onOpenTutorial={() => setIsTutorialOpen(true)}
                onOpenStats={() => setIsStatsOpen(true)}
                onOpenComparator={() => setIsComparatorOpen(true)}
                history={history}
                onClearHistory={clearHistory}
                onRemoveHistory={removeFromHistory}
                isLoading={activeTab?.loading}
            >
                <TabsBar
                    tabs={tabs}
                    activeTabId={activeTabId}
                    onSwitch={switchTab}
                    onClose={closeTab}
                    onNewTab={() => createTab(activeTab?.document || 'nesh')}
                />

                <div className={styles.resultsSection}>
                    {/* Renderizacao persistente das abas - usa TabPanel para lazy loading + keep alive */}
                    {tabs.map(tab => (
                        <TabPanel
                            key={tab.id}
                            id={tab.id}
                            activeTabId={activeTabId}
                            className={styles.tabPane}
                        >
                            {/* Loading unificado: mostra skeleton se carregando OU se o conteudo ainda nao esta pronto */}
                            {(tab.loading || (tab.results && tab.isContentReady === false)) && <ResultSkeleton />}

                            {tab.error && (
                                <div className={styles.emptyState}>
                                    <h3 className={styles.emptyStateTitle}>Erro</h3>
                                    <p>{tab.error}</p>
                                </div>
                            )}

                            {!tab.loading && !tab.results && !tab.error && (
                                <div className={styles.emptyState}>
                                    <div className={styles.emptyStateIcon}>üîé</div>
                                    <h3 className={styles.emptyStateTitle}>Pronto para buscar</h3>
                                    <p>Digite um NCM acima ou use o hist√≥rico</p>
                                    <p className={styles.emptyStateHint}>
                                        Dica: Pressione <kbd>/</kbd> para buscar
                                    </p>
                                </div>
                            )}

                            {!tab.loading && tab.results && (
                                <ResultDisplay
                                    data={tab.results}
                                    mobileMenuOpen={tab.id === activeTabId ? mobileMenuOpen : false}
                                    onCloseMobileMenu={tab.id === activeTabId ? closeMobileMenu : noop}
                                    isActive={tab.id === activeTabId}
                                    tabId={tab.id}
                                    isNewSearch={tab.isNewSearch || false}
                                    onConsumeNewSearch={(_finalScroll) => {
                                        const updates: Partial<any> = { isNewSearch: false };
                                        if (typeof _finalScroll === 'number') {
                                            updates.scrollTop = _finalScroll;
                                        }
                                        updateTab(tab.id, updates);
                                    }}
                                    // Persistencia explicita do scroll para robustez em unmounts/otimizacoes
                                    initialScrollTop={tab.scrollTop}
                                    onPersistScroll={(id, top) => updateTab(id, { scrollTop: top })}
                                    onContentReady={() => {
                                        if (!tab.isContentReady) {
                                            updateTab(tab.id, { isContentReady: true });
                                        }
                                    }}
                                />
                            )}
                            {/* Esconder visualmente ResultDisplay se nao estiver pronto? Nao, manter montado para o IntersectionObserver rodar,
                                apenas cobrir com Skeleton (posicionado absoluto) ou controlar visibilidade via CSS se precisar.
                                Na pratica o ResultDisplay controla sua propria visibilidade via isContentReady.
                            */}
                        </TabPanel>
                    ))}
                </div>
            </Layout>
        </>
    );
}

export default App;


==================================================
FILE: client/src/components/ComparatorModal.tsx
==================================================
import { useCallback, useEffect, useMemo, useState } from 'react';
import { toast } from 'react-hot-toast';
import { searchNCM, searchTipi } from '../services/api';
import { useSettings } from '../context/SettingsContext';
import { MarkdownPane } from './MarkdownPane';
import { Loading } from './Loading';
import styles from './ComparatorModal.module.css';

type DocType = 'nesh' | 'tipi';

interface ComparatorModalProps {
    isOpen: boolean;
    onClose: () => void;
    defaultDoc?: DocType;
}

type PanelState = {
    ncm: string;
    title: string;
    markdown: string | null;
    loading: boolean;
};

const emptyPanel = (title: string): PanelState => ({
    ncm: '',
    title,
    markdown: null,
    loading: false
});

export function ComparatorModal({ isOpen, onClose, defaultDoc = 'nesh' }: ComparatorModalProps) {
    const { tipiViewMode } = useSettings();

    const [doc, setDoc] = useState<DocType>(defaultDoc);
    const [left, setLeft] = useState<PanelState>(() => emptyPanel('Esquerda'));
    const [right, setRight] = useState<PanelState>(() => emptyPanel('Direita'));

    // Keep doc in sync when opening (so it follows current UI context)
    useEffect(() => {
        if (isOpen) setDoc(defaultDoc);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isOpen]);

    // Body scroll lock
    useEffect(() => {
        if (!isOpen) return;
        const prevOverflow = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
        return () => {
            document.body.style.overflow = prevOverflow;
        };
    }, [isOpen]);

    // Close on ESC
    useEffect(() => {
        if (!isOpen) return;
        const onKeyDown = (e: KeyboardEvent) => {
            if (e.key === 'Escape') onClose();
        };
        window.addEventListener('keydown', onKeyDown);
        return () => window.removeEventListener('keydown', onKeyDown);
    }, [isOpen, onClose]);

    const canCompare = useMemo(() => {
        return left.ncm.trim().length > 0 && right.ncm.trim().length > 0;
    }, [left.ncm, right.ncm]);

    const fetchSide = useCallback(async (ncm: string, side: 'left' | 'right') => {
        const clean = ncm.trim();
        if (!clean) return;

        const setPanel = side === 'left' ? setLeft : setRight;
        setPanel(prev => ({ ...prev, loading: true, title: `Buscando ${clean}...` }));

        try {
            const data = doc === 'nesh'
                ? await searchNCM(clean)
                : await searchTipi(clean, tipiViewMode);

            const markdown = data?.markdown || data?.resultados || null;
            setPanel({
                ncm: clean,
                title: `${doc.toUpperCase()} ${clean}`,
                markdown,
                loading: false
            });
        } catch (e: any) {
            console.error(e);
            setPanel(prev => ({
                ...prev,
                loading: false,
                title: `${doc.toUpperCase()} ${clean}`,
                markdown: null
            }));
            toast.error('Erro ao comparar. Verifique a API.');
        }
    }, [doc, tipiViewMode]);

    const onCompare = useCallback(async () => {
        if (!canCompare) {
            toast.error('Preencha ambos os NCMs.');
            return;
        }
        await Promise.all([
            fetchSide(left.ncm, 'left'),
            fetchSide(right.ncm, 'right')
        ]);
    }, [canCompare, fetchSide, left.ncm, right.ncm]);

    const onSubmit = useCallback((e: React.FormEvent) => {
        e.preventDefault();
        onCompare();
    }, [onCompare]);

    if (!isOpen) return null;

    return (
        <div className={styles.overlay} onClick={onClose}>
            <div className={styles.content} onClick={(e) => e.stopPropagation()}>
                <div className={styles.header}>
                    <div className={styles.headerTitle}>
                        <h2 className={styles.headerHeading}>‚öñÔ∏è Comparar NCMs</h2>
                        <div className={`${styles.docSelector} ${styles.docSelectorInline}`}>
                            <button
                                className={`${styles.docButton} ${doc === 'nesh' ? styles.docButtonActive : ''}`}
                                type="button"
                                onClick={() => setDoc('nesh')}
                            >
                                NESH
                            </button>
                            <button
                                className={`${styles.docButton} ${doc === 'tipi' ? styles.docButtonActive : ''}`}
                                type="button"
                                onClick={() => setDoc('tipi')}
                            >
                                TIPI
                            </button>
                        </div>
                    </div>
                    <button className={styles.closeButton} onClick={onClose} aria-label="Fechar">√ó</button>
                </div>

                <form className={styles.inputs} onSubmit={onSubmit}>
                    <div className={styles.inputGroup}>
                        <label htmlFor="compareLeft">NCM Esquerda</label>
                        <input
                            id="compareLeft"
                            className={styles.input}
                            value={left.ncm}
                            onChange={(e) => setLeft(prev => ({ ...prev, ncm: e.target.value }))}
                            placeholder="Ex: 8517"
                        />
                    </div>
                    <div className={styles.vs}>VS</div>
                    <div className={styles.inputGroup}>
                        <label htmlFor="compareRight">NCM Direita</label>
                        <input
                            id="compareRight"
                            className={styles.input}
                            value={right.ncm}
                            onChange={(e) => setRight(prev => ({ ...prev, ncm: e.target.value }))}
                            placeholder="Ex: 8471"
                        />
                    </div>

                    <button
                        className={styles.compareButton}
                        type="submit"
                        disabled={!canCompare}
                        title="Comparar"
                    >
                        ‚öñÔ∏è Comparar
                    </button>
                </form>

                <div className={styles.body}>
                    <div className={styles.panel}>
                        <div className={styles.panelHeader}>{left.title}</div>
                        <div className={styles.panelContent}>
                            {left.loading ? (
                                <Loading />
                            ) : (
                                <MarkdownPane markdown={left.markdown} className="markdown-body" />
                            )}
                        </div>
                    </div>

                    <div className={styles.divider} />

                    <div className={styles.panel}>
                        <div className={styles.panelHeader}>{right.title}</div>
                        <div className={styles.panelContent}>
                            {right.loading ? (
                                <Loading />
                            ) : (
                                <MarkdownPane markdown={right.markdown} className="markdown-body" />
                            )}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
}


==================================================
FILE: client/src/types/api.types.ts
==================================================
// ============================================
// API Response Types ‚Äî Nesh/Fiscal
// ============================================
// Interfaces TypeScript para todas as respostas da API.
// Garante type-safety no frontend e evita erros de runtime.

// --------------------------------------------
// Base Types
// --------------------------------------------

/** Base para todas as respostas da API */
export interface BaseApiResponse {
    success: boolean;
}

/** Resposta de erro padronizada do backend */
export interface ApiErrorResponse extends BaseApiResponse {
    success: false;
    error: {
        code: string;
        message: string;
        details?: {
            field?: string;
            query?: string;
            resource?: string;
            identifier?: string;
            path?: string;
            service?: string;
            chapter_num?: string;
        } | null;
    };
}

// --------------------------------------------
// NESH Search Types
// --------------------------------------------

/** Item de resultado de busca textual (FTS) */
export interface TextSearchResultItem {
    ncm: string;
    descricao: string;
    tipo: 'chapter' | 'position' | 'subposition';
    relevancia: number;
    score: number;
    tier: 1 | 2 | 3;
    tier_label: 'Exato' | 'Todas palavras' | 'Parcial';
    near_bonus?: boolean;
}

/** Resposta de busca textual NESH */
export interface TextSearchResponse extends BaseApiResponse {
    success: true;
    type: 'text';
    query: string;
    normalized: string;
    match_type: 'exact' | 'all_words' | 'partial' | 'none' | 'error';
    warning: string | null;
    results: TextSearchResultItem[];
    total_capitulos: number;
}

/** Posi√ß√£o NCM dentro de um cap√≠tulo */
export interface ChapterPosition {
    ncm?: string;
    codigo: string;
    descricao: string;
    anchor_id: string;
    // TIPI-specific (optional for NESH)
    aliquota?: string;
    nivel?: number;
}

/** Se√ß√µes estruturadas do cap√≠tulo */
export interface ChapterSections {
    titulo: string | null;
    notas: string | null;
    consideracoes: string | null;
    definicoes: string | null;
}

/** Dados de um cap√≠tulo NESH */
export interface ChapterData {
    ncm_buscado: string;
    capitulo: string;
    posicao_alvo: string | null;
    posicoes: ChapterPosition[];
    notas_gerais: string | null;
    notas_parseadas: Record<string, string>;
    conteudo: string;
    real_content_found: boolean;
    erro: string | null;
    secoes?: ChapterSections;
}

/** Resposta de busca por c√≥digo NESH */
export interface CodeSearchResponse extends BaseApiResponse {
    success: true;
    type: 'code';
    query: string;
    normalized: null;
    results: Record<string, ChapterData>;
    resultados?: Record<string, ChapterData>; // Legacy alias
    total_capitulos: number;
    markdown?: string; // Rendered HTML
}

/** Union type para resposta de busca NESH */
export type NeshSearchResponse = TextSearchResponse | CodeSearchResponse;

// --------------------------------------------
// TIPI Search Types
// --------------------------------------------

/** Posi√ß√£o TIPI com al√≠quota */
export interface TipiPosition {
    ncm: string;
    codigo: string;
    descricao: string;
    aliquota: string;
    nivel: number;
    anchor_id: string;
}

/** Cap√≠tulo TIPI */
export interface TipiChapterData {
    capitulo: string;
    titulo: string;
    notas_gerais: string | null;
    posicao_alvo: string | null;
    posicoes: TipiPosition[];
}

/** Resposta de busca TIPI por c√≥digo */
export interface TipiCodeSearchResponse extends BaseApiResponse {
    success: true;
    type: 'code';
    query: string;
    results: Record<string, TipiChapterData>;
    resultados: Record<string, TipiChapterData>;
    total: number;
    total_capitulos: number;
    markdown?: string;
}

/** Item de resultado de busca textual TIPI */
export interface TipiTextResultItem {
    ncm: string;
    capitulo: string;
    descricao: string;
    aliquota: string;
}

/** Resposta de busca TIPI textual */
export interface TipiTextSearchResponse extends BaseApiResponse {
    success: true;
    type: 'text';
    query: string;
    normalized: string;
    match_type: string;
    warning: string | null;
    total: number;
    results: TipiTextResultItem[];
}

/** Union type para resposta de busca TIPI */
export type TipiSearchResponse = TipiCodeSearchResponse | TipiTextSearchResponse;

/** Union gen√©rico para qualquer resposta de busca */
export type SearchResponse = NeshSearchResponse | TipiSearchResponse;

// --------------------------------------------
// Other Endpoints
// --------------------------------------------

/** Resposta do gloss√°rio */
export interface GlossaryResponse {
    found: boolean;
    term: string;
    data?: {
        definition: string;
        source?: string;
    };
}

/** Cap√≠tulo na lista de cap√≠tulos */
export interface ChapterListItem {
    codigo: string;
    titulo: string;
    secao?: string;
}

/** Resposta de lista de cap√≠tulos */
export interface ChaptersListResponse extends BaseApiResponse {
    success: true;
    capitulos: ChapterListItem[] | string[];
}

/** Status do banco de dados */
export interface DatabaseStatus {
    status: 'online' | 'error';
    chapters?: number;
    positions?: number;
    latency_ms?: number;
    error?: string;
}

/** Status do sistema */
export interface SystemStatusResponse {
    status: 'online' | 'error';
    version: string;
    backend: string;
    database: DatabaseStatus;
    tipi: DatabaseStatus;
}

/** Login response */
export interface LoginResponse extends BaseApiResponse {
    success: boolean;
    token?: string;
    message: string;
}

// --------------------------------------------
// Type Guards
// --------------------------------------------

/** Verifica se a resposta √© de busca textual */
export function isTextSearchResponse(
    response: NeshSearchResponse | TipiSearchResponse
): response is TextSearchResponse | TipiTextSearchResponse {
    return response.type === 'text';
}

/** Verifica se a resposta √© de busca por c√≥digo */
export function isCodeSearchResponse(
    response: NeshSearchResponse | TipiSearchResponse
): response is CodeSearchResponse | TipiCodeSearchResponse {
    return response.type === 'code';
}

/** Verifica se a resposta √© um erro da API */
export function isApiError(response: unknown): response is ApiErrorResponse {
    return (
        typeof response === 'object' &&
        response !== null &&
        'success' in response &&
        (response as BaseApiResponse).success === false &&
        'error' in response
    );
}


